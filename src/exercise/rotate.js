/*
给定一个数据. 将数组中的元素向有移动k个位置,其中k是个负整数

示例1: 
    输入 [1,2,3,4,5,6,7] 和 k =3;
    输出 [5,6,7,1,2,3,4]
解释:
    向右旋转 1 步: [7,1,2,3,4,5,6]
    向右旋转 2 步: [6,7,1,2,3,4,5]
    向右旋转 3 步: [5,6,7,1,2,3,4]

示例2:
    输入: [-1, -100, 3, 99] 和 k = 2;
    输出: [3, 99, -1, -100]

解释:
    向右旋转 1 步: [99,-1,-100,3]
    向右旋转 2 步: [3,99,-1,-100]

尽可能想出更多的解决方案, 至少有三种不同的方法可以解决这个问题
要求使用空间复杂度O(1) 的 原地 算法
*/

/**
 * 参考答案:
 *
 *
 * 如果一个数组的长度为n, 向右旋转 k 次, 其实就跟没有旋转一样, 所以实际上要旋转的次数step = n%k.
 *
 * 方法一:
 *
 * 向右旋转1次, 就是将素组最后面的元素搬到最前面,使用javascript array的pop() 可以去除最后一个元素
 *
 * unshift(x) 可以将元素差到数组前面
 * 方法二:
 *
 * 用一个暂存数组temp存储向右旋转的元素, 需要旋转k次temp里面就有几个元素.
 * 题目要求只能在一开始的nums数组内操作,所以接下来就是把nums内没有被旋转的元素搬到nums的后面,接着将temp放到nums的前面
 *
 * @param {*} nums
 */
export function rotate(nums, k) {
    const temp = [];
    const length = nums.length;

    for (let i = length - 1; i >= length - k; i--) {
        temp.push(nums.pop());
    }

    for (let i = 0; i < temp.length; i++) {
        nums.unshift(temp[i]);
    }
}
