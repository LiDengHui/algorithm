/**
 * 题目: 132模式序列
 * 
 * 给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。

如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。

进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？

示例 1：

输入：nums = [1,2,3,4]
输出：false
解释：序列中不存在 132 模式的子序列。
示例 2：

输入：nums = [3,1,4,2]
输出：true
解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。
示例 3：

输入：nums = [-1,3,2,0]
输出：true
解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。
 
提示：

n == nums.length
1 <= n <= 104
-109 <= nums[i] <= 109

链接：https://leetcode-cn.com/problems/132-pattern

 */

/**
 * 解法一: 枚举 1
 *
 * 思路:
 *
 * 如果我们从左枚举1的下标i, 那么 j,k的下标范围都在减少,这样不利于对他们进行维护.因此我们可以考虑从右向左枚举i
 *
 * 那么我们应该如何维护j,k呢? 在132模式中,如果1<2并且2<3,那么根据传递性, 1<3也成立,那么我们可以使用下面的方法进行维护:
 * 1. 我们使用一种数据结构维护所有遍历过的元素,他们作为2的候选元素.每当我们遍历到一个新的元素时,就将其加入到数据结构中
 * 2. 在遍历到一个新的元素的同时,我们可以考虑其是否可以作为3,如果他作为3,那幕数据结构中所有严格小于他的元素都可以作为2,我们将这些元素全部从数据结构中移除
 * 并且使用一个变量维护所有被移除的元素的最大值,这些被移除的元素都是可以真正作为2的,并且元素的值越大,那么我们之后找到1的机会也就越大
 *
 * 那么这个数据结构是怎么样的数据结构呢》我们尝试提取他进行的操作
 *
 * 1. 他需要支持添加一个元素
 * 2. 他需要支持移除所有严格小于给定阈值的所有元素
 * 3, 上面两部操作是依次进行的,即我们先用给定的阈值移除元素,再将该阈值加入数据结构中
 *
 * 这就是单调栈,在单调栈中,从栈底带栈顶的元素是严格单调递减的,当给定阈值x时,我们只需要不断的弹出栈顶的元素,直到栈为空或者x严格小于栈顶元素,
 * 此时我们再将x入栈,这样就维护了栈的单调性
 *
 * 因此,我们使用单调栈最为维护2的数据结构,并给出下面的算法:
 * 1. 我们用单调栈维护所有可以作为2的候选元素.初始时,单调栈中只有为恶意的元素a[n-1]. 我们环需要一个变量max_k 记录所有可以真正作为2的元素的最大值
 * 2. 随后我们从 n-2 开始从右到左枚举元素a[i]:
 *   * 首先我们判断a[i]是否可以作为1. 如果a[i]<max_k, 那么它就可以作为1,我们就找到了一组满足132模式的三元组
 *   * 随后我们判断a[i]是否可以作为3, 以此找出哪些可以真正作为2的元素.我们将a[i]不断的与单调栈栈顶的元素进行比较,如果a[i]较大
 *     那么栈顶的元素可以真正作为2,将其弹出并更新max_k
 *   * 最后我们将a[i]作为2的候选元素放入单调栈中, 这里可以进行一个优化, 即如果a[i]<=max_k , 那么我们也没有必要将a[i]放入栈中因为即使他在未来被弹出,也不会将
 *      max_k 更新为最大的值
 * 3. 在枚举完所有的元素后,如果仍未找到满足132模式的三元组,那就说明其不存在.
 *
 * 复杂度分析
 *
 * 时间复杂度: O(n),枚举i的次数为O(n),由于每一个元素最多被加入和弹出单调栈各一次,因此操作单调栈的时间复杂度一共为O(n), 总时间复杂度为O(n)
 * 空间复杂度: O(n), 及为单调栈需要使用的空间
 *
 * @param {*} nums
 * @returns
 */
export function find132Pattern(nums) {
    const n = nums.length;
    const candidate_k = [nums[n - 1]];
    let max_k = -Number.MAX_SAFE_INTEGER;

    for (let i = n - 2; i >= 0; i--) {
        if (nums[i] < max_k) return true;
        while (
            candidate_k.length &&
            nums[i] > candidate_k[candidate_k.length - 1]
        ) {
            max_k = candidate_k[candidate_k.length - 1];
            candidate_k.pop();
        }

        if (nums[i] > max_k) {
            candidate_k.push(nums[i]);
        }
    }
    return false;
}
